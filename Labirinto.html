<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labirinto dos Tesouros</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
       
        body {
            background-color: #1a202c;
            color: white;
            touch-action: pan-x pan-y;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .game-container {
            flex: 1;
            width: 100%;
            max-width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .maze-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding-bottom: 120px; /* Espa√ßo para os controles */
        }

        .controls {
            position: sticky;
            bottom: 20px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 240px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            z-index: 100;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .controls { 
                display: grid;
                bottom: 20px;
            }
        }

        .maze-container {
            display: inline-block;
            border: 2px solid #4a5568;
            padding: 2px;
            background-color: #1a202c;
        }
        .maze-row {
            display: flex;
            margin: 0;
            padding: 0;
        }
        .cell {
            width: min(32px, 6vw);
            height: min(32px, 6vw);
            margin: 0;
            padding: 0;
            border: 1px solid #2d3748;
        }
        .wall { background-color: #1a202c; }
        .path { background-color: #2d3748; }
        .player {
            background-color: #48bb78;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .enemy {
            background-color: #f56565;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .treasure {
            background-color: #f6e05e;
            animation: shine 1s infinite;
        }
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .game-over.active { display: flex; }
        .heart-full {
            color: #f56565;
            display: inline-block;
            margin: 0 2px;
        }
        .heart-empty {
            color: #4a5568;
            display: inline-block;
            margin: 0 2px;
        }
        .control-btn {
            background: rgba(74, 85, 104, 0.7);
            border-radius: 8px;
            padding: 15px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        .control-btn:active {
            background: rgba(74, 85, 104, 0.9);
        }
       
        .bullet {
            background-color: white;
            border-radius: 50%;
            width: 10px !important;
            height: 10px !important;
            position: relative;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            animation: shine 1s infinite;
        }

        .shot {
            position: relative;
        }

        .shot::after {
            content: '';
            position: absolute;
            background-color: white;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .enemy-hit {
            animation: explode 0.3s ease-out;
            z-index: 10;
        }

        @keyframes explode {
            0% { 
                transform: scale(1); 
                background-color: #f56565;
            }
            50% { 
                transform: scale(1.8); 
                background-color: #ff9999;
                box-shadow: 0 0 20px #ff0000;
            }
            100% { 
                transform: scale(1); 
                background-color: #f56565;
            }
        }

        @keyframes pulse {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(0.95); }
        }
        @keyframes shine {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">
    <div class="game-container">
        <div class="text-white mb-4 text-center">
            <h1 class="text-3xl font-bold mb-2">Labirinto dos Tesouros</h1>
            <div class="flex justify-center items-center space-x-6">
                <div>N√≠vel: <span id="level">1</span></div>
                <div>Pontua√ß√£o: <span id="score">0</span></div>
                <div>Tesouros: <span id="treasures">0</span></div>
                <div>Balas: <span id="bullets">0</span></div>
            </div>
            <div class="mb-2" id="lives"></div>
        </div>
        
        <div class="maze-wrapper">
            <div id="maze" class="maze-container"></div>
            <div class="controls">
                <div></div>
                <div class="control-btn text-center" id="btnUp">üîº</div>
                <div></div>
                <div class="control-btn text-center" id="btnLeft">‚óÄÔ∏è</div>
                <div class="control-btn text-center" id="btnShoot">üéØ</div>
                <div class="control-btn text-center" id="btnRight">‚ñ∂Ô∏è</div>
                <div></div>
                <div class="control-btn text-center" id="btnDown">üîΩ</div>
                <div></div>
            </div>
        </div>
    </div>
    
    <div id="gameOver" class="game-over">
        <div class="bg-gray-800 p-8 rounded-lg text-white text-center">
            <h2 class="text-2xl mb-4">Game Over!</h2>
            <p class="mb-4">Pontua√ß√£o Final: <span id="finalScore">0</span></p>
            <p class="hidden md:block mb-4 text-gray-400">Pressione Enter para jogar novamente</p>
            <button onclick="startGame()" class="md:hidden bg-green-500 px-4 py-2 rounded hover:bg-green-600">
                Clique aqui para jogar novamente
            </button>
        </div>
    </div>

    <script>
        const MAZE_SIZE = 15;
        let maze = [];
        let player = { x: 1, y: 1 };
        let enemies = [];
        let treasures = [];
        let level = 1;
        let score = 0;
        let lives = 3;
        let gameInterval;
        let isGameOver = false;
        let moveCounter = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let moveInterval = null;
        let moveSpeed = 150; // Velocidade inicial de movimento
        let holdStartTime = 0;
        let currentDirection = null;
        let bullets = 0;
        let shots = [];
        let lastDirection = 'right'; // Dire√ß√£o inicial do jogador

        function createMaze() {
            maze = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            
            function recursiveBacktracking(x, y) {
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                maze[y][x] = 0;
                
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;
                    const middleX = x + dx/2;
                    const middleY = y + dy/2;
                    
                    if (nextX > 0 && nextX < MAZE_SIZE - 1 && 
                        nextY > 0 && nextY < MAZE_SIZE - 1 && 
                        maze[nextY][nextX] === 1) {
                        maze[middleY][middleX] = 0;
                        maze[nextY][nextX] = 0;
                        recursiveBacktracking(nextX, nextY);
                    }
                }
            }
            
            recursiveBacktracking(1, 1);
            
            // Aumenta o n√∫mero de caminhos extras (era MAZE_SIZE * 1.5)
            for (let i = 0; i < MAZE_SIZE * 3; i++) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 1) {
                    const neighbors = [
                        [x+1, y], [x-1, y],
                        [x, y+1], [x, y-1]
                    ].filter(([nx, ny]) => 
                        nx > 0 && nx < MAZE_SIZE - 1 &&
                        ny > 0 && ny < MAZE_SIZE - 1 &&
                        maze[ny][nx] === 0
                    );
                    
                    // Aumenta a probabilidade de criar caminhos (era neighbors.length >= 2)
                    if (neighbors.length >= 1 && Math.random() < 0.8) { // Aumentou probabilidade tamb√©m
                        maze[y][x] = 0;
                    }
                }
            }
            
            // Garante √°reas mais abertas perto do jogador e inimigo
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (1 + dx > 0 && 1 + dx < MAZE_SIZE - 1 && 
                        1 + dy > 0 && 1 + dy < MAZE_SIZE - 1) {
                        maze[1 + dy][1 + dx] = 0;
                    }
                    if (MAZE_SIZE - 2 + dx > 0 && MAZE_SIZE - 2 + dx < MAZE_SIZE - 1 && 
                        MAZE_SIZE - 2 + dy > 0 && MAZE_SIZE - 2 + dy < MAZE_SIZE - 1) {
                        maze[MAZE_SIZE - 2 + dy][MAZE_SIZE - 2 + dx] = 0;
                    }
                }
            }
            
            maze[1][1] = 0;
            maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 0;
            
            return maze;
        }

        function createEnemy(x, y) {
            if (!x || !y) {
                // Tenta 20 vezes encontrar uma posi√ß√£o v√°lida
                for (let i = 0; i < 20; i++) {
                    x = Math.floor(Math.random() * (MAZE_SIZE - 4)) + 2;
                    y = Math.floor(Math.random() * (MAZE_SIZE - 4)) + 2;
                    
                    // Verifica se a posi√ß√£o √© v√°lida, longe de outros inimigos e do jogador
                    const distanceFromPlayer = Math.abs(player.x - x) + Math.abs(player.y - y);
                    if (maze[y][x] === 0 && 
                        !enemies.some(e => Math.abs(e.x - x) < 4 && Math.abs(e.y - y) < 4) &&
                        distanceFromPlayer > 8) {
                        break;
                    }
                }
                // Se n√£o encontrar posi√ß√£o ideal, coloca no canto oposto ao jogador
                if (maze[y][x] !== 0 || (Math.abs(player.x - x) + Math.abs(player.y - y)) <= 8) {
                    x = MAZE_SIZE - 2;
                    y = MAZE_SIZE - 2;
                }
            }
            return { x, y };
        }

        function placeTreasures() {
            const numTreasures = Math.min(3 + Math.floor(level / 2), 10);
            treasures = [];
            
            while (treasures.length < numTreasures) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 0 && 
                    !treasures.some(t => t.x === x && t.y === y) &&
                    !(x === player.x && y === player.y) &&
                    !enemies.some(e => e.x === x && e.y === y)) {
                    treasures.push({x, y});
                }
            }
        }

        function updateLives() {
            const livesContainer = document.getElementById('lives');
            const heartsHtml = Array(5).fill(0).map((_, i) => // Mudado de 3 para 5
                i < lives ? '‚ù§Ô∏è' : '<span style="opacity: 0.3">‚ù§Ô∏è</span>'
            ).join('');
            livesContainer.innerHTML = heartsHtml;
        }


        function renderMaze() {
            const mazeElement = document.getElementById('maze');
            mazeElement.innerHTML = '';
            
            for (let y = 0; y < MAZE_SIZE; y++) {
                const row = document.createElement('div');
                row.className = 'maze-row';
                
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    } else {
                        cell.classList.add('path');
                    }
                    
                    if (x === player.x && y === player.y) {
                        cell.classList.add('player');
                    }

                    if (enemies.some(e => e.x === x && e.y === y)) {
                        cell.classList.add('enemy');
                        const enemy = enemies.find(e => e.x === x && e.y === y);
                        if (enemy.exploding) {
                            cell.classList.add('enemy-hit');
                        }
                    }

                    if (treasures.some(t => t.x === x && t.y === y)) {
                        cell.classList.add('treasure');
                    }

                    // Adicione renderiza√ß√£o de tiros
                    if (shots.some(shot => shot.x === x && shot.y === y)) {
                        cell.classList.add('shot');
                    }
                    
                    // Adicione renderiza√ß√£o de balas colet√°veis
                    if (maze[y][x] === 2) { // 2 representa uma bala colet√°vel
                        const bullet = document.createElement('div');
                        bullet.className = 'bullet';
                        cell.appendChild(bullet);
                    }
                    
                    row.appendChild(cell);
                }
                mazeElement.appendChild(row);
            }

            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('treasures').textContent = treasures.length;
            updateLives();
        }

        function findPathToPlayer(enemy) {
            const queue = [{x: enemy.x, y: enemy.y, path: []}];
            const visited = new Set();
            
            // Fun√ß√£o auxiliar para gerar chave √∫nica para cada posi√ß√£o
            const posKey = (x, y) => `${x},${y}`;
            visited.add(posKey(enemy.x, enemy.y));
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Se encontrou o jogador, retorna o primeiro movimento do caminho
                if (current.x === player.x && current.y === player.y) {
                    if (current.path.length > 0) {
                        return current.path[0];
                    }
                    return null;
                }
                
                // Verifica todas as dire√ß√µes poss√≠veis
                const directions = [
                    {dx: 0, dy: -1}, // cima
                    {dx: 1, dy: 0},  // direita
                    {dx: 0, dy: 1},  // baixo
                    {dx: -1, dy: 0}  // esquerda
                ];
                
                for (const dir of directions) {
                    const nextX = current.x + dir.dx;
                    const nextY = current.y + dir.dy;
                    const key = posKey(nextX, nextY);
                    
                    if (nextX >= 0 && nextX < MAZE_SIZE && 
                        nextY >= 0 && nextY < MAZE_SIZE && 
                        maze[nextY][nextX] === 0 && 
                        !visited.has(key)) {
                        
                        visited.add(key);
                        const newPath = [...current.path, {x: nextX, y: nextY}];
                        queue.push({x: nextX, y: nextY, path: newPath});
                    }
                }
            }
            
            return null;
        }

        function moveEnemy(enemy) {
            if (enemy.exploding) return;
            
            // Encontra o pr√≥ximo movimento no melhor caminho
            const nextMove = findPathToPlayer(enemy);
            
            if (nextMove) {
                enemy.x = nextMove.x;
                enemy.y = nextMove.y;
                return;
            }
            
            // Se n√£o encontrar caminho, usa o movimento antigo como fallback
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            
            let moveX = 0;
            let moveY = 0;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? 1 : -1;
            } else {
                moveY = dy > 0 ? 1 : -1;
            }
            
            if (maze[enemy.y + moveY][enemy.x + moveX] === 0) {
                enemy.x += moveX;
                enemy.y += moveY;
            } 
            else if (moveX !== 0 && maze[enemy.y][enemy.x + moveX] === 0) {
                enemy.x += moveX;
            } 
            else if (moveY !== 0 && maze[enemy.y + moveY][enemy.x] === 0) {
                enemy.y += moveY;
            }
        }

        function checkCollision() {
            if (isGameOver) return;

            // Verifica colis√£o com inimigos
            const hitEnemy = enemies.find(enemy => 
                enemy.x === player.x && 
                enemy.y === player.y && 
                !enemy.exploding  // Adiciona esta verifica√ß√£o
            );

            if (hitEnemy) {
                lives--;
                updateLives();
                
                if (lives <= 0) {
                    gameOver();
                } else {
                    // Reposiciona o jogador e inimigos
                    player = { x: 1, y: 1 };
                    enemies.forEach(enemy => {
                        const newPos = createEnemy();
                        enemy.x = newPos.x;
                        enemy.y = newPos.y;
                    });
                }
                return;
            }
            
            // Verifica coleta de tesouro
            const treasureIndex = treasures.findIndex(t => t.x === player.x && t.y === player.y);
            if (treasureIndex !== -1) {
                treasures.splice(treasureIndex, 1);
                score += 100 * level;
                
                if (treasures.length === 0) {
                    levelUp();
                }
            }

            // Verifica coleta de balas
            if (maze[player.y][player.x] === 2) {
                maze[player.y][player.x] = 0;
                addBullet();
            }
        }

        function levelUp() {
            level++;
            score += 500 * level;
            maze = createMaze();
            player = { x: 1, y: 1 };
            
            // Adiciona novo inimigo a cada 5 n√≠veis
            if (level % 5 === 0) {
                enemies.push(createEnemy());
            }
            
            // Reposiciona todos os inimigos aleatoriamente
            enemies = enemies.map(() => createEnemy());
            
            placeTreasures();
        }

        function gameOver() {
            stopContinuousMove();
            isGameOver = true;
            clearInterval(gameInterval);
            document.getElementById('gameOver').classList.add('active');
            document.getElementById('finalScore').textContent = score;
        }

        function startGame() {
            stopContinuousMove();
            isGameOver = false;
            level = 1;
            score = 0;
            lives = 5;
            bullets = 5; // Come√ßa com algumas balas
            updateBulletsDisplay();
            maze = createMaze();
            player = { x: 1, y: 1 };
            enemies = [createEnemy()];
            placeTreasures();
            document.getElementById('gameOver').classList.remove('active');
            updateLives();
            
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            
            moveCounter = 0;
            gameInterval = setInterval(() => {
                moveCounter++;
                if (moveCounter % 3 === 0) {
                    enemies.forEach(moveEnemy);
                }
                updateShots(); // Certifique-se de que esta linha est√° presente
                checkCollision();
                renderMaze();
                
                // Chance de gerar nova bala (3%)
                if (Math.random() < 0.03) {
                    generateNewBullet();
                }
            }, 200);
        }

        function updateBulletsDisplay() {
            document.getElementById('bullets').textContent = bullets;
        }

        function generateNewBullet() {
            for (let i = 0; i < 20; i++) { // Mais tentativas para encontrar posi√ß√£o v√°lida
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                // Verifica se est√° longe de jogador e inimigos
                const farFromPlayer = Math.abs(x - player.x) + Math.abs(y - player.y) > 3;
                const farFromEnemies = !enemies.some(e => 
                    Math.abs(e.x - x) < 3 && Math.abs(e.y - y) < 3
                );
                
                if (maze[y][x] === 0 && farFromPlayer && farFromEnemies) {
                    maze[y][x] = 2;
                    return true;
                }
            }
            return false;
        }

        function movePlayer(direction) {
            if (isGameOver) return;

            lastDirection = direction;
            const newPlayer = { ...player };
            
            if (direction === 'up') newPlayer.y--;
            else if (direction === 'down') newPlayer.y++;
            else if (direction === 'left') newPlayer.x--;
            else if (direction === 'right') newPlayer.x++;
            
            // Modifique esta linha para permitir movimento sobre balas (valor 2)
            if (maze[newPlayer.y][newPlayer.x] === 0 || maze[newPlayer.y][newPlayer.x] === 2) {
                player = newPlayer;
                checkCollision();
                renderMaze();
            }
        }

        // Controles de teclado
        // Adicione esta fun√ß√£o para prevenir as teclas padr√£o
        function preventDefaultForArrowKeys(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }

        // Modifique o event listener do teclado para incluir a preven√ß√£o
        document.addEventListener('keydown', (e) => {
            // Previne scroll com teclas direcionais
            preventDefaultForArrowKeys(e);

            // L√≥gica de game over e Enter
            if (isGameOver && e.key === 'Enter') {
                startGame();
                return;
            }

            // Movimento do jogador
            if (isGameOver) return;

            const key = e.key;
            
            if (key === 'ArrowUp') movePlayer('up');
            else if (key === 'ArrowDown') movePlayer('down');
            else if (key === 'ArrowLeft') movePlayer('left');
            else if (key === 'ArrowRight') movePlayer('right');

            // Controle do tiro
            if (e.key === ' ' || e.code === 'Space') {
                shoot();
                return;
            }
            
        });

        // Opcionalmente, tamb√©m previna o scroll quando as teclas estiverem pressionadas
        document.addEventListener('keypress', preventDefaultForArrowKeys);

        // Previne comportamentos indesejados do touch
        document.addEventListener('touchstart', (e) => {
            if (e.target.classList.contains('control-btn')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Impede que o usu√°rio d√™ zoom na tela mobile com double tap
        document.addEventListener('dblclick', (e) => {
            e.preventDefault();
        }, { passive: false });

        
        // Fun√ß√£o auxiliar para iniciar movimento cont√≠nuo
        function startContinuousMove(direction) {
            if (moveInterval && currentDirection === direction) return;
            
            stopContinuousMove(); // Limpa qualquer movimento anterior
            currentDirection = direction;
            holdStartTime = Date.now();
            
            movePlayer(direction); // Move imediatamente
            
            moveInterval = setInterval(() => {
                movePlayer(direction);
                
                // Calcula quanto tempo o bot√£o est√° sendo segurado
                const holdDuration = Date.now() - holdStartTime;
                
                // Ajusta a velocidade baseado no tempo segurado
                if (holdDuration > 500) { // Ap√≥s 0.5 segundo
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 30); // Muito r√°pido
                } else if (holdDuration > 200) { // Ap√≥s 0.2 segundos
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 100); // R√°pido
                }
            }, moveSpeed);
        }

        function stopContinuousMove() {
            if (moveInterval) {
                clearInterval(moveInterval);
                moveInterval = null;
            }
            moveSpeed = 150; // Reseta a velocidade
            currentDirection = null;
            holdStartTime = 0;
        }

        function addBullet() {
            bullets++;
            updateBulletsDisplay();
        }

        function updateBulletsDisplay() {
            const bulletDisplay = document.getElementById('bullets');
            bulletDisplay.textContent = bullets;
        }

        function shoot() {
            if (bullets <= 0) return;
            
            // Inicia o tiro na mesma posi√ß√£o do jogador
            const shot = {
                x: player.x,
                y: player.y,
                direction: lastDirection
            };
            
            // Verifica se a pr√≥xima posi√ß√£o √© v√°lida antes de criar o tiro
            let validShot = false;
            switch(lastDirection) {
                case 'up':
                    if (maze[player.y - 1][player.x] !== 1) {
                        validShot = true;
                    }
                    break;
                case 'down':
                    if (maze[player.y + 1][player.x] !== 1) {
                        validShot = true;
                    }
                    break;
                case 'left':
                    if (maze[player.y][player.x - 1] !== 1) {
                        validShot = true;
                    }
                    break;
                case 'right':
                    if (maze[player.y][player.x + 1] !== 1) {
                        validShot = true;
                    }
                    break;
            }
            
            if (validShot) {
                bullets--;
                updateBulletsDisplay();
                shots.push(shot);
            }
        }

        function updateShots() {
            for (let i = shots.length - 1; i >= 0; i--) {
                const shot = shots[i];
                let nextX = shot.x;
                let nextY = shot.y;
                
                switch(shot.direction) {
                    case 'up': nextY--; break;
                    case 'down': nextY++; break;
                    case 'left': nextX--; break;
                    case 'right': nextX++; break;
                }
                
                // Remove tiro se bater em parede
                if (maze[nextY][nextX] === 1) {
                    shots.splice(i, 1);
                    continue;
                }
                
                // Verifica colis√£o com inimigos na posi√ß√£o atual E na pr√≥xima posi√ß√£o
                const hitEnemy = enemies.findIndex(enemy => {
                    // Verifica colis√£o na posi√ß√£o atual da bala
                    if (enemy.x === shot.x && enemy.y === shot.y) return true;
                    // Verifica colis√£o na pr√≥xima posi√ß√£o da bala
                    if (enemy.x === nextX && enemy.y === nextY) return true;
                    // Verifica se o inimigo e a bala "cruzaram" caminhos
                    if (enemy.x === nextX && enemy.y === shot.y) return true;
                    if (enemy.x === shot.x && enemy.y === nextY) return true;
                    return false;
                });
                
                if (hitEnemy !== -1 && !enemies[hitEnemy].exploding) {
                    enemies[hitEnemy].exploding = true;
                    shots.splice(i, 1);
                    
                    // Posi√ß√£o atual do inimigo atingido
                    const currentX = enemies[hitEnemy].x;
                    const currentY = enemies[hitEnemy].y;
                    
                    setTimeout(() => {
                        if (enemies[hitEnemy]) {
                            enemies[hitEnemy].exploding = false;
                            const newPos = createEnemy();
                            enemies[hitEnemy].x = newPos.x;
                            enemies[hitEnemy].y = newPos.y;
                        }
                    }, 300);
                    continue;
                }
                
                shot.x = nextX;
                shot.y = nextY;
            }
        }

        // Atualiza os event listeners dos bot√µes
        ['Up', 'Down', 'Left', 'Right'].forEach(direction => {
            const btn = document.getElementById(`btn${direction}`);
            const dir = direction.toLowerCase();

            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousMove(dir);
            });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopContinuousMove();
            });

            // Mouse events para desktop
            btn.addEventListener('mousedown', () => {
                startContinuousMove(dir);
            });

            btn.addEventListener('mouseup', () => {
                stopContinuousMove();
            });

            btn.addEventListener('mouseleave', () => {
                stopContinuousMove();
            });
        });

        // Mobile
        document.getElementById('btnShoot').addEventListener('touchstart', (e) => {
            e.preventDefault();
            shoot();
        });

        document.getElementById('btnShoot').addEventListener('click', () => {
            shoot();
        });

        // Inicia o jogo
        startGame();
    </script>
</body>
</html>
