<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labirinto dos Tesouros</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
       
        body {
            background-color: #1a202c;
            color: white;
            touch-action: pan-x pan-y;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .game-container {
            flex: 1;
            width: 100%;
            max-width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 600px;
            margin: 10px auto;
            position: relative;
            padding: 0 20px;
        }

        .d-pad {
            position: absolute;
            left: 5px;
            display: flex;
            flex-direction: column;
           
            width: 125px;  /* Reduzido para ficar mais compacto */
        }

        .d-pad-row {
            display: grid;
            grid-template-columns: 60px 60px 60px;
           
            justify-content: start; /* Alinha √† esquerda */
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(74, 85, 104, 0.7);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        .shoot-control {
            margin-left: auto;
            width: 60px;
        }

        .control-btn:active {
            background: rgba(74, 85, 104, 0.9);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                padding-right: 40px; /* Aumentado para mover mais √† direita */
            }
        }

        @media (max-width: 400px) {
            .mobile-controls {
                padding: 0 20px;
            }
            
            .d-pad {
                width: 150px;
            }
        }

        .maze-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 120px; /* Espa√ßo para os controles */
        }

        .controls {
            position: sticky;
            bottom: 20px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 240px;
            padding: 0px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            z-index: 100;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .controls { 
                display: grid;
                bottom: 20px;
            }
        }
        .maze-container {
            display: inline-block;
            border: 2px solid #4a5568;
            padding: 2px;
            background-color: #1a202c;
        }
        .maze-row {
            display: flex;
            margin: 0;
            padding: 0;
        }
        .cell {
            width: min(32px, 6vw);
            height: min(32px, 6vw);
            margin: 0;
            padding: 0;
            border: 1px solid #2d3748;
        }
        .wall { background-color: #1a202c; }
        .path { background-color: #2d3748; }
        .player {
            background-color: #48bb78;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .enemy {
            background-color: #f56565;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .treasure {
            background-color: #f6e05e;
            animation: shine 1s infinite;
        }
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .game-over.active { display: flex; }
        .heart-full {
            color: #f56565;
            display: inline-block;
            margin: 0 2px;
        }
        .heart-empty {
            color: #4a5568;
            display: inline-block;
            margin: 0 2px;
        }
        .control-btn:active {
            background: rgba(74, 85, 104, 0.9);
        }
       
        .bullet {
            background-color: white;
            border-radius: 50%;
            width: 10px !important;
            height: 10px !important;
            position: relative;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            animation: shine 1s infinite;
        }

        .shot {
            position: relative;
        }

        .shot::after {
            content: '';
            position: absolute;
            background-color: white;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .enemy-hit {
            animation: explode 0.3s ease-out;
            z-index: 10;
        }

        @keyframes explode {
            0% { 
                transform: scale(1); 
                background-color: #f56565;
            }
            50% { 
                transform: scale(1.8); 
                background-color: #ff9999;
                box-shadow: 0 0 20px #ff0000;
            }
            100% { 
                transform: scale(1); 
                background-color: #f56565;
            }
        }

        @keyframes pulse {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(0.95); }
        }

        @keyframes shine {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">
    <div class="game-container">
      
        <div class="text-white mb-4 text-center">
            <!-- T√≠tulo -->
            <div class="w-full max-w-2xl mx-auto mb-2">
                <h1 class="text-xl md:text-3xl font-bold">Labirinto dos Tesouros</h1>
            </div>
            <!-- Container para as informa√ß√µes do jogo -->
            <div class="flex flex-wrap justify-center gap-4 text-sm md:text-base">
                <div>N√≠vel: <span id="level">1</span></div>
                <div>Pontua√ß√£o: <span id="score">0</span></div>
                <div>Tesouros: <span id="treasures">0</span></div>
                <div>Balas: <span id="bullets">0</span></div>
            </div>
            
            <!-- Container para vidas e bot√£o de pausa -->
            <div class="flex justify-center items-center gap-4 mb-2">
                <div id="lives"></div>
                <button id="pauseButton" class="bg-gray-800 hover:bg-gray-700 text-white font-bold p-0.5 rounded text-xs mt-1">
                    ‚è∏Ô∏è
                </button>
            </div>
        </div>
        
        <!-- Adicione o overlay de pausa logo ap√≥s -->
        <div id="pauseOverlay" class="fixed inset-0 bg-black bg-opacity-80 hidden flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg text-white text-center">
                <h2 class="text-2xl mb-4">Jogo Pausado</h2>
                <p class="hidden md:block mb-4 text-gray-400">Pressione P ou clique para continuar</p>
                <button id="resumeButton" class="bg-green-500 px-4 py-2 rounded hover:bg-green-600">
                    Continuar
                </button>
            </div>
        </div>
        
        <div class="maze-wrapper">
            <div id="maze" class="maze-container"></div>
            <div class="mobile-controls">
                <div class="d-pad">
                    <div class="d-pad-row">
                        <div></div>
                        <div class="control-btn" id="btnUp">üîº</div>
                        <div></div>
                    </div>
                    <div class="d-pad-row">
                        <div class="control-btn" id="btnLeft">‚óÄÔ∏è</div>
                        <div class="control-btn" id="btnDown">üîΩ</div>
                        <div class="control-btn" id="btnRight">‚ñ∂Ô∏è</div>
                    </div>
                </div>
                <div class="shoot-control">
                    <div class="control-btn" id="btnShoot">‚ö™</div>
                </div>
            </div>
         </div>
    </div>
    
    <div id="gameOver" class="game-over">
        <div class="bg-gray-800 p-8 rounded-lg text-white text-center">
            <h2 class="text-2xl mb-4">Game Over!</h2>
            <p class="mb-4">N√≠vel Alcan√ßado: <span id="finalLevel">0</span></p>
            <p class="mb-4">Pontua√ß√£o Final: <span id="finalScore">0</span></p>
            <p class="hidden md:block mb-4 text-gray-400">Pressione Enter para jogar novamente</p>
            <button onclick="startGame()" class="md:hidden bg-green-500 px-4 py-2 rounded hover:bg-green-600">
                Clique aqui para jogar novamente
            </button>
        </div>
    </div>

    <script>
        const MAZE_SIZE = 15;
        let maze = [];
        let player = { x: 1, y: 1 };
        let enemies = [];
        let treasures = [];
        let level = 0;
        let score = 0;
        let lives = 0;
        let gameInterval;
        let isGameOver = false;
        let moveCounter = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let moveInterval = null;
        let moveSpeed = 150; // Velocidade inicial de movimento
        let holdStartTime = 0;
        let currentDirection = null;
        let bullets = 0;
        let shots = [];
        let lastDirection = 'right'; // Dire√ß√£o inicial do jogador
        let bulletSpawnChance = 0.03;
        let isPaused = false;

        // _________________________________________________________________
        //
        // Controle do som
        // _________________________________________________________________

        class AudioManager {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.sounds = {};
                this.isMuted = false;
                this.loadSounds();
            }

            async loadSounds() {
                // Fun√ß√£o auxiliar para tocar uma sequ√™ncia de notas
                const playSequence = (notes) => {
                    notes.forEach((note, index) => {
                        setTimeout(() => {
                            const oscillator = this.context.createOscillator();
                            const gainNode = this.context.createGain();
                            
                            oscillator.type = note.type || 'sine';
                            oscillator.frequency.setValueAtTime(note.frequency, this.context.currentTime);
                            
                            gainNode.gain.setValueAtTime(note.gain || 0.2, this.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + note.duration);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.context.destination);
                            
                            oscillator.start();
                            oscillator.stop(this.context.currentTime + note.duration);
                        }, index * 100); // 100ms entre cada nota
                    });
                };

                // Fun√ß√£o auxiliar para criar sons usando oscilador
                const createOscillatorSound = (frequency, duration, type = 'sine') => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = type;
                    oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    return { oscillator, gainNode, duration };
                };

                // Som de tiro (som agudo curto)
                this.sounds.shoot = () => {
                    const sound = createOscillatorSound(880, 0.1, 'square');
                    sound.oscillator.start();
                    sound.oscillator.stop(this.context.currentTime + sound.duration);
                };

                // Som de coleta de tesouro (som ascendente)
                this.sounds.collectTreasure = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, this.context.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0.5, this.context.currentTime); // Aumentado de ~0.2 para 0.5
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.2);
                };

                // Som de morte do inimigo (som descendente com ru√≠do)
                this.sounds.enemyDeath = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(110, this.context.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.3);
                };

                // Som de morte do jogador (som grave e longo)
                this.sounds.playerDeath = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(55, this.context.currentTime + 0.5);
                    
                    gainNode.gain.setValueAtTime(0.7, this.context.currentTime); // Aumentado de 0.4 para 0.7
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.5);
                };

                // Melodia de game over (sequ√™ncia de notas tristes descendentes)
                this.sounds.gameOver = () => {
                    const baseFreq = 440; // Nota A4
                    const notes = [
                        { frequency: baseFreq, duration: 0.2, type: 'sine', gain: 0.5 },      // A4 (mais alto)
                        { frequency: baseFreq * 0.75, duration: 0.2, type: 'sine', gain: 0.45 }, // F4
                        { frequency: baseFreq * 0.5, duration: 0.4, type: 'sine', gain: 0.4 }, // A3
                        { frequency: baseFreq * 0.25, duration: 0.6, type: 'sine', gain: 0.35 }  // A2 (ainda aud√≠vel)
                    ];
                    playSequence(notes);
                };

                // Melodia de level up (sequ√™ncia de notas alegres em arpejo)
                this.sounds.levelUp = () => {
                    const baseFreq = 440; // Nota A4
                    const notes = [
                        { frequency: baseFreq, duration: 0.15, type: 'sine', gain: 0.2 },       // A4
                        { frequency: baseFreq * 1.25, duration: 0.15, type: 'sine', gain: 0.2 }, // C#5
                        { frequency: baseFreq * 1.5, duration: 0.15, type: 'sine', gain: 0.2 },  // E5
                        { frequency: baseFreq * 2, duration: 0.2, type: 'sine', gain: 0.25 },    // A5 (mais longa e um pouco mais alta)
                    ];
                    playSequence(notes);
                };
            }

            play(soundName) {
                if (this.isMuted || !this.sounds[soundName]) return;
                
                // Garante que o contexto est√° executando (necess√°rio devido √†s pol√≠ticas dos navegadores)
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                
                this.sounds[soundName]();
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                return this.isMuted;
            }
        }

        // Cria uma inst√¢ncia global do gerenciador de √°udio
        const audioManager = new AudioManager();

        // Adiciona bot√£o de mute na interface
        const addMuteButton = () => {
            const controls = document.querySelector('.flex.justify-center.items-center.gap-4.mb-2');
            const muteButton = document.createElement('button');
            muteButton.className = 'bg-gray-800 hover:bg-gray-700 text-white font-bold p-0.5 rounded text-xs mt-1';
            muteButton.innerHTML = 'üîä';
            muteButton.onclick = () => {
                const isMuted = audioManager.toggleMute();
                muteButton.innerHTML = isMuted ? 'üîà' : 'üîä';
            };
            controls.appendChild(muteButton);
        };

        // Chama a fun√ß√£o para adicionar o bot√£o quando a p√°gina carregar
        window.addEventListener('load', addMuteButton);

        // _________________________________________________________________
        //
        // Labirinto
        // _________________________________________________________________

        function createMaze() {
            maze = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            
            function recursiveBacktracking(x, y) {
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                maze[y][x] = 0;
                
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;
                    const middleX = x + dx/2;
                    const middleY = y + dy/2;
                    
                    if (nextX > 0 && nextX < MAZE_SIZE - 1 && 
                        nextY > 0 && nextY < MAZE_SIZE - 1 && 
                        maze[nextY][nextX] === 1) {
                        maze[middleY][middleX] = 0;
                        maze[nextY][nextX] = 0;
                        recursiveBacktracking(nextX, nextY);
                    }
                }
            }
            
            recursiveBacktracking(1, 1);
            
            // Aumenta o n√∫mero de caminhos extras (era MAZE_SIZE * 1.5)
            for (let i = 0; i < MAZE_SIZE * 3; i++) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 1) {
                    const neighbors = [
                        [x+1, y], [x-1, y],
                        [x, y+1], [x, y-1]
                    ].filter(([nx, ny]) => 
                        nx > 0 && nx < MAZE_SIZE - 1 &&
                        ny > 0 && ny < MAZE_SIZE - 1 &&
                        maze[ny][nx] === 0
                    );
                    
                    // Aumenta a probabilidade de criar caminhos (era neighbors.length >= 2)
                    if (neighbors.length >= 1 && Math.random() < 0.8) { // Aumentou probabilidade tamb√©m
                        maze[y][x] = 0;
                    }
                }
            }
            
            // Garante √°reas mais abertas perto do jogador e inimigo
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (1 + dx > 0 && 1 + dx < MAZE_SIZE - 1 && 
                        1 + dy > 0 && 1 + dy < MAZE_SIZE - 1) {
                        maze[1 + dy][1 + dx] = 0;
                    }
                    if (MAZE_SIZE - 2 + dx > 0 && MAZE_SIZE - 2 + dx < MAZE_SIZE - 1 && 
                        MAZE_SIZE - 2 + dy > 0 && MAZE_SIZE - 2 + dy < MAZE_SIZE - 1) {
                        maze[MAZE_SIZE - 2 + dy][MAZE_SIZE - 2 + dx] = 0;
                    }
                }
            }
            
            maze[1][1] = 0;
            maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 0;
            
            return maze;
        }

        function createEnemy(x, y) {
            if (!x || !y) {
                // Tenta 20 vezes encontrar uma posi√ß√£o v√°lida
                for (let i = 0; i < 20; i++) {
                    x = Math.floor(Math.random() * (MAZE_SIZE - 4)) + 2;
                    y = Math.floor(Math.random() * (MAZE_SIZE - 4)) + 2;
                    
                    // Verifica se a posi√ß√£o √© v√°lida, longe de outros inimigos e do jogador
                    const distanceFromPlayer = Math.abs(player.x - x) + Math.abs(player.y - y);
                    if (maze[y][x] === 0 && 
                        !enemies.some(e => Math.abs(e.x - x) < 4 && Math.abs(e.y - y) < 4) &&
                        distanceFromPlayer > 8) {
                        break;
                    }
                }
                // Se n√£o encontrar posi√ß√£o ideal, coloca no canto oposto ao jogador
                if (maze[y][x] !== 0 || (Math.abs(player.x - x) + Math.abs(player.y - y)) <= 8) {
                    x = MAZE_SIZE - 2;
                    y = MAZE_SIZE - 2;
                }
            }
            return { x, y };
        }

        function placeTreasures() {

            // Aumenta n√∫mero de tesouros ap√≥s n√≠vel 15
            const baseNumTreasures = 3 + Math.floor(level / 2);
            const bonusTreasures = level > 15 ? Math.floor((level - 15) / 3) : 0;
            const numTreasures = Math.min(baseNumTreasures + bonusTreasures, 15); // M√°ximo de 15 tesouros
            
            treasures = [];
            
            while (treasures.length < numTreasures) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 0 && 
                    !treasures.some(t => t.x === x && t.y === y) &&
                    !(x === player.x && y === player.y) &&
                    !enemies.some(e => e.x === x && e.y === y)) {
                    treasures.push({x, y});
                }
            }
        }

        function updateLives() {
            const livesContainer = document.getElementById('lives');
            const heartsHtml = Array(7).fill(0).map((_, i) => 
                i < lives ? '‚ù§Ô∏è' : '<span style="opacity: 0.3">‚ù§Ô∏è</span>'
            ).join('');
            livesContainer.innerHTML = heartsHtml;
        }


        function renderMaze() {
            const mazeElement = document.getElementById('maze');
            mazeElement.innerHTML = '';
            
            for (let y = 0; y < MAZE_SIZE; y++) {
                const row = document.createElement('div');
                row.className = 'maze-row';
                
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    } else {
                        cell.classList.add('path');
                    }
                    
                    if (x === player.x && y === player.y) {
                        cell.classList.add('player');
                    }

                    if (enemies.some(e => e.x === x && e.y === y)) {
                        cell.classList.add('enemy');
                        const enemy = enemies.find(e => e.x === x && e.y === y);
                        if (enemy.exploding) {
                            cell.classList.add('enemy-hit');
                        }
                    }

                    if (treasures.some(t => t.x === x && t.y === y)) {
                        cell.classList.add('treasure');
                    }

                    // Adicione renderiza√ß√£o de tiros
                    if (shots.some(shot => shot.x === x && shot.y === y)) {
                        cell.classList.add('shot');
                    }
                    
                    // Adicione renderiza√ß√£o de balas colet√°veis
                    if (maze[y][x] === 2) { // 2 representa uma bala colet√°vel
                        const bullet = document.createElement('div');
                        bullet.className = 'bullet';
                        cell.appendChild(bullet);
                    }
                    
                    row.appendChild(cell);
                }
                mazeElement.appendChild(row);
            }

            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('treasures').textContent = treasures.length;
            updateLives();
        }

        function findPathToPlayer(enemy) {
            const queue = [{x: enemy.x, y: enemy.y, path: []}];
            const visited = new Set();
            
            // Fun√ß√£o auxiliar para gerar chave √∫nica para cada posi√ß√£o
            const posKey = (x, y) => `${x},${y}`;
            visited.add(posKey(enemy.x, enemy.y));
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Se encontrou o jogador, retorna o primeiro movimento do caminho
                if (current.x === player.x && current.y === player.y) {
                    if (current.path.length > 0) {
                        return current.path[0];
                    }
                    return null;
                }
                
                // Verifica todas as dire√ß√µes poss√≠veis
                const directions = [
                    {dx: 0, dy: -1}, // cima
                    {dx: 1, dy: 0},  // direita
                    {dx: 0, dy: 1},  // baixo
                    {dx: -1, dy: 0}  // esquerda
                ];
                
                for (const dir of directions) {
                    const nextX = current.x + dir.dx;
                    const nextY = current.y + dir.dy;
                    const key = posKey(nextX, nextY);
                    
                    if (nextX >= 0 && nextX < MAZE_SIZE && 
                        nextY >= 0 && nextY < MAZE_SIZE && 
                        maze[nextY][nextX] === 0 && 
                        !visited.has(key)) {
                        
                        visited.add(key);
                        const newPath = [...current.path, {x: nextX, y: nextY}];
                        queue.push({x: nextX, y: nextY, path: newPath});
                    }
                }
            }
            
            return null;
        }

        function moveEnemy(enemy) {
            if (enemy.exploding) return;
            
            // Encontra o pr√≥ximo movimento no melhor caminho
            const nextMove = findPathToPlayer(enemy);
            
            if (nextMove) {
                enemy.x = nextMove.x;
                enemy.y = nextMove.y;
                return;
            }
            
            // Se n√£o encontrar caminho, usa o movimento antigo como fallback
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            
            let moveX = 0;
            let moveY = 0;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? 1 : -1;
            } else {
                moveY = dy > 0 ? 1 : -1;
            }
            
            if (maze[enemy.y + moveY][enemy.x + moveX] === 0) {
                enemy.x += moveX;
                enemy.y += moveY;
            } 
            else if (moveX !== 0 && maze[enemy.y][enemy.x + moveX] === 0) {
                enemy.x += moveX;
            } 
            else if (moveY !== 0 && maze[enemy.y + moveY][enemy.x] === 0) {
                enemy.y += moveY;
            }
        }

        function checkCollision() {
            if (isGameOver) return;

            // Verifica colis√£o com inimigos
            const hitEnemy = enemies.find(enemy => 
                enemy.x === player.x && 
                enemy.y === player.y && 
                !enemy.exploding  // Adiciona esta verifica√ß√£o
            );

            if (hitEnemy) {
                lives--;
                updateLives();

                if (lives > 0) {
                    audioManager.play('playerDeath'); // Adiciona som de morte do jogador
                }

                if (lives <= 0) {
                    gameOver();
                } else {
                    // Reposiciona o jogador e inimigos
                    player = { x: 1, y: 1 };
                    enemies.forEach(enemy => {
                        const newPos = createEnemy();
                        enemy.x = newPos.x;
                        enemy.y = newPos.y;
                    });
                }
                return;
            }
            
            // Verifica coleta de tesouro
            const treasureIndex = treasures.findIndex(t => t.x === player.x && t.y === player.y);
            if (treasureIndex !== -1) {
                treasures.splice(treasureIndex, 1);
                score += 100 * level;
                audioManager.play('collectTreasure'); // Adiciona som de coleta
                
                if (treasures.length === 0) {
                    // Adiciona um pequeno delay antes de chamar levelUp
                    setTimeout(() => {
                        levelUp();
                    }, 300); // 300ms de delay
                }
            }

            // Verifica coleta de balas
            if (maze[player.y][player.x] === 2) {
                maze[player.y][player.x] = 0;
                addBullet();
            }
        }

        function levelUp() {
            level++;
            score += 500 * level;
            maze = createMaze();
            player = { x: 1, y: 1 };
            
            audioManager.play('levelUp');
            
            // Adiciona inimigos em n√≠veis espec√≠ficos
            if (level === 5) enemies.push(createEnemy());
            else if (level === 10) enemies.push(createEnemy());
            else if (level === 15) enemies.push(createEnemy());
            
            // Reposiciona todos os inimigos existentes
            enemies = enemies.map(() => createEnemy());
            
            // Aumenta chance de balas conforme n√≠vel aumenta
            bulletSpawnChance = Math.min(0.05 + (level * 0.01), 0.2); // Aumentado significativamente
            
            // Garante um n√∫mero m√≠nimo de balas ao iniciar o n√≠vel
            const minBullets = 2 + Math.floor(level / 6); // Come√ßa com 3 balas e aumenta a cada 5 n√≠veis
            for (let i = 0; i < minBullets; i++) {
                generateNewBullet();
            }
            
            placeTreasures();
        }

        function gameOver() {

            // Toca a melodia de game over
            audioManager.play('gameOver');

            stopContinuousMove();
            isGameOver = true;
            clearInterval(gameInterval);
            document.getElementById('gameOver').classList.add('active');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
        }

        function startGame() {
            stopContinuousMove();
            isGameOver = false;
            level = 1; // Para come√ßar em n√≠vel diferente, altere aqui
            score = 0;
            lives = 7;
            bullets = 10; // Come√ßa com algumas balas
            updateBulletsDisplay();
            maze = createMaze();
            player = { x: 1, y: 1 };
            enemies = [createEnemy()];
            placeTreasures();
            document.getElementById('gameOver').classList.remove('active');
            updateLives();
            
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            
            moveCounter = 0;
            gameInterval = setInterval(() => {
                if (!isPaused) {
                    moveCounter++;
                    if (moveCounter % 3 === 0) {
                        enemies.forEach(moveEnemy);
                    }
                    updateShots();
                    checkCollision();
                    renderMaze();
                    
                    // Tenta gerar nova bala a cada tick do intervalo
                    if (Math.random() < bulletSpawnChance) {
                        generateNewBullet();
                    }
                }
            }, 200);
        }

        function updateBulletsDisplay() {
            document.getElementById('bullets').textContent = bullets;
        }

        function generateNewBullet() {
            // Conta quantas balas existem no mapa
            let currentBullets = 0;
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[y][x] === 2) currentBullets++;
                }
            }

            // Se j√° tiver muitas balas, n√£o gera mais
            const maxBullets = 3 + Math.floor(level / 4); // Aumenta com o n√≠vel
            if (currentBullets >= maxBullets) return false;

            // Lista todas as posi√ß√µes v√°lidas
            const validPositions = [];
            for (let y = 1; y < MAZE_SIZE - 1; y++) {
                for (let x = 1; x < MAZE_SIZE - 1; x++) {
                    // Verifica se √© um caminho e est√° longe do jogador e inimigos
                    const farFromPlayer = Math.abs(x - player.x) + Math.abs(y - player.y) > 3;
                    const farFromEnemies = !enemies.some(e => 
                        Math.abs(e.x - x) < 3 && Math.abs(e.y - y) < 3
                    );
                    
                    if (maze[y][x] === 0 && farFromPlayer && farFromEnemies) {
                        validPositions.push({x, y});
                    }
                }
            }

            // Se encontrou posi√ß√µes v√°lidas, escolhe uma aleatoriamente
            if (validPositions.length > 0) {
                const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
                maze[pos.y][pos.x] = 2;
                return true;
            }

            return false;
        }

        function movePlayer(direction) {
            if (isGameOver || isPaused) return;

            lastDirection = direction;
            const newPlayer = { ...player };
            
            if (direction === 'up') newPlayer.y--;
            else if (direction === 'down') newPlayer.y++;
            else if (direction === 'left') newPlayer.x--;
            else if (direction === 'right') newPlayer.x++;
            
            // Modifique esta linha para permitir movimento sobre balas (valor 2)
            if (maze[newPlayer.y][newPlayer.x] === 0 || maze[newPlayer.y][newPlayer.x] === 2) {
                player = newPlayer;
                checkCollision();
                renderMaze();
            }
        }

        // Controles de teclado
        // Adicione esta fun√ß√£o para prevenir as teclas padr√£o
        function preventDefaultForArrowKeys(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }

        // Modifique o event listener do teclado para incluir a preven√ß√£o
        document.addEventListener('keydown', (e) => {
            // Previne scroll com teclas direcionais
            preventDefaultForArrowKeys(e);

            // L√≥gica de game over e Enter
            if (isGameOver && e.key === 'Enter') {
                startGame();
                return;
            }

            // Movimento do jogador
            if (isGameOver) return;

            const key = e.key;
            
            if (key === 'ArrowUp') movePlayer('up');
            else if (key === 'ArrowDown') movePlayer('down');
            else if (key === 'ArrowLeft') movePlayer('left');
            else if (key === 'ArrowRight') movePlayer('right');

            // Controle do tiro
            if (e.key === ' ' || e.code === 'Space') {
                shoot();
                return;
            }
            
            // Tecla P para pausar
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        // Opcionalmente, tamb√©m previna o scroll quando as teclas estiverem pressionadas
        document.addEventListener('keypress', preventDefaultForArrowKeys);

        // Previne comportamentos indesejados do touch
        document.addEventListener('touchstart', (e) => {
            if (e.target.classList.contains('control-btn')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Impede que o usu√°rio d√™ zoom na tela mobile com double tap
        document.addEventListener('dblclick', (e) => {
            e.preventDefault();
        }, { passive: false });

        
        // Fun√ß√£o auxiliar para iniciar movimento cont√≠nuo
        function startContinuousMove(direction) {
            if (moveInterval && currentDirection === direction) return;
            
            stopContinuousMove(); // Limpa qualquer movimento anterior
            currentDirection = direction;
            holdStartTime = Date.now();
            
            movePlayer(direction); // Move imediatamente
            
            moveInterval = setInterval(() => {
                movePlayer(direction);
                
                // Calcula quanto tempo o bot√£o est√° sendo segurado
                const holdDuration = Date.now() - holdStartTime;
                
                // Ajusta a velocidade baseado no tempo segurado
                if (holdDuration > 500) { // Ap√≥s 0.5 segundo
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 30); // Muito r√°pido
                } else if (holdDuration > 200) { // Ap√≥s 0.2 segundos
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 100); // R√°pido
                }
            }, moveSpeed);
        }

        function stopContinuousMove() {
            if (moveInterval) {
                clearInterval(moveInterval);
                moveInterval = null;
            }
            moveSpeed = 150; // Reseta a velocidade
            currentDirection = null;
            holdStartTime = 0;
        }

        function addBullet() {
            bullets++;
            updateBulletsDisplay();
        }

        function updateBulletsDisplay() {
            const bulletDisplay = document.getElementById('bullets');
            bulletDisplay.textContent = bullets;
        }

        function findNearestEnemy(fromX, fromY) {
            let nearestEnemy = null;
            let shortestDistance = Infinity;
            
            enemies.forEach(enemy => {
                if (enemy.exploding) return;
                
                const distance = Math.abs(fromX - enemy.x) + Math.abs(fromY - enemy.y);
                if (distance < shortestDistance) {
                    shortestDistance = distance;
                    nearestEnemy = enemy;
                }
            });
            
            return nearestEnemy;
        }

        function getDirectionToEnemy(fromX, fromY, enemy) {
            const dx = enemy.x - fromX;
            const dy = enemy.y - fromY;
            
            // Determina a dire√ß√£o predominante
            if (Math.abs(dx) > Math.abs(dy)) {
                return dx > 0 ? 'right' : 'left';
            } else {
                return dy > 0 ? 'down' : 'up';
            }
        }

        function shoot() {

            if (bullets <= 0 || isPaused) return;
            
            const nearestEnemy = findNearestEnemy(player.x, player.y);
            if (!nearestEnemy) return; // N√£o atira se n√£o houver inimigos vivos
            
            bullets--;
            updateBulletsDisplay();
            audioManager.play('shoot'); // Adiciona som de tiro

            const direction = getDirectionToEnemy(player.x, player.y, nearestEnemy);
            const shot = {
                x: player.x,
                y: player.y,
                direction: direction
            };
            
            // Verifica se o primeiro movimento √© v√°lido
            let nextX = shot.x;
            let nextY = shot.y;
            
            switch(direction) {
                case 'up': nextY--; break;
                case 'down': nextY++; break;
                case 'left': nextX--; break;
                case 'right': nextX++; break;
            }
            
            if (maze[nextY][nextX] !== 1) {
                shots.push(shot);
            } else {
                // Devolve a bala se n√£o puder atirar
                bullets++;
                updateBulletsDisplay();
            }
        }

        function updateShots() {
            for (let i = shots.length - 1; i >= 0; i--) {
                const shot = shots[i];
                let nextX = shot.x;
                let nextY = shot.y;
                
                switch(shot.direction) {
                    case 'up': nextY--; break;
                    case 'down': nextY++; break;
                    case 'left': nextX--; break;
                    case 'right': nextX++; break;
                }
                
                // Remove tiro se bater em parede
                if (maze[nextY][nextX] === 1) {
                    shots.splice(i, 1);
                    continue;
                }
                
                // Verifica colis√£o com inimigos na posi√ß√£o atual E na pr√≥xima posi√ß√£o
                const hitEnemy = enemies.findIndex(enemy => {
                    // Verifica colis√£o na posi√ß√£o atual da bala
                    if (enemy.x === shot.x && enemy.y === shot.y) return true;
                    // Verifica colis√£o na pr√≥xima posi√ß√£o da bala
                    if (enemy.x === nextX && enemy.y === nextY) return true;
                    // Verifica se o inimigo e a bala "cruzaram" caminhos
                    if (enemy.x === nextX && enemy.y === shot.y) return true;
                    if (enemy.x === shot.x && enemy.y === nextY) return true;
                    return false;
                });
                
                if (hitEnemy !== -1 && !enemies[hitEnemy].exploding) {
                    enemies[hitEnemy].exploding = true;
                    shots.splice(i, 1);
                    audioManager.play('enemyDeath'); // Adiciona som de morte do inimigo

                    // Posi√ß√£o atual do inimigo atingido
                    const currentX = enemies[hitEnemy].x;
                    const currentY = enemies[hitEnemy].y;
                    
                    setTimeout(() => {
                        if (enemies[hitEnemy]) {
                            enemies[hitEnemy].exploding = false;
                            const newPos = createEnemy();
                            enemies[hitEnemy].x = newPos.x;
                            enemies[hitEnemy].y = newPos.y;
                        }
                    }, 300);
                    continue;
                }
                
                shot.x = nextX;
                shot.y = nextY;
            }
        }

        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            const pauseOverlay = document.getElementById('pauseOverlay');
            
            if (isPaused) {
                // Para tudo limpando o intervalo principal do jogo
                clearInterval(gameInterval);
                pauseOverlay.classList.remove('hidden');
            } else {
                pauseOverlay.classList.add('hidden');
                // Recria o intervalo principal do jogo
                gameInterval = setInterval(() => {
                    if (!isPaused) {
                        moveCounter++;
                        if (moveCounter % 3 === 0) {
                            enemies.forEach(moveEnemy);  // movimento dos inimigos
                        }
                        updateShots();  // atualiza√ß√£o dos tiros
                        checkCollision();  // checagem de colis√µes
                        renderMaze();  // renderiza√ß√£o do labirinto
                        
                        // gera√ß√£o de novas balas
                        if (Math.random() < bulletSpawnChance) {
                            generateNewBullet();
                        }
                    }
                }, 200);
            }
        }

        // Atualiza os event listeners dos bot√µes
        ['Up', 'Down', 'Left', 'Right'].forEach(direction => {
            const btn = document.getElementById(`btn${direction}`);
            const dir = direction.toLowerCase();

            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousMove(dir);
            });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopContinuousMove();
            });

            // Mouse events para desktop
            btn.addEventListener('mousedown', () => {
                startContinuousMove(dir);
            });

            btn.addEventListener('mouseup', () => {
                stopContinuousMove();
            });

            btn.addEventListener('mouseleave', () => {
                stopContinuousMove();
            });
        });

        // Mobile
        document.getElementById('btnShoot').addEventListener('touchstart', (e) => {
            e.preventDefault();
            shoot();
        });

        document.getElementById('btnShoot').addEventListener('click', () => {
            shoot();
        });

        // Pause/Resume
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        document.getElementById('resumeButton').addEventListener('click', togglePause);

        // Inicia o jogo
        startGame();
    </script>
</body>
</html>
