<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labirinto dos Tesouros</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
       
        body {
            background-color: #1a202c;
            color: white;
            touch-action: pan-x pan-y;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .game-container {
            flex: 1;
            width: 100%;
            max-width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 600px;
            margin: 10px auto;
            position: relative;
            padding: 0 20px;
        }

        .d-pad {
            position: absolute;
            left: 5px;
            display: flex;
            flex-direction: column;
           
            width: 125px;  /* Reduzido para ficar mais compacto */
        }

        .d-pad-row {
            display: grid;
            grid-template-columns: 60px 60px 60px;
           
            justify-content: start; /* Alinha √† esquerda */
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(74, 85, 104, 0.7);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        .shoot-control {
            margin-left: auto;
            width: 60px;
        }

        .control-btn:active {
            background: rgba(74, 85, 104, 0.9);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                padding-right: 40px; /* Aumentado para mover mais √† direita */
            }
        }

        @media (max-width: 400px) {
            .mobile-controls {
                padding: 0 20px;
            }
            
            .d-pad {
                width: 150px;
            }
        }

        .maze-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 120px; /* Espa√ßo para os controles */
        }

        .controls {
            position: sticky;
            bottom: 20px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 240px;
            padding: 0px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            z-index: 100;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .controls { 
                display: grid;
                bottom: 20px;
            }
        }
        .maze-container {
            display: inline-block;
            border: 2px solid #4a5568;
            padding: 2px;
            background-color: #1a202c;
        }
        .maze-row {
            display: flex;
            margin: 0;
            padding: 0;
        }
        .cell {
            width: min(32px, 6vw);
            height: min(32px, 6vw);
            margin: 0;
            padding: 0;
            border: 1px solid #2d3748;
        }
        .wall { background-color: #1a202c; }
        .path { background-color: #2d3748; }
        .player {
            background-color: #48bb78;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .enemy {
            background-color: #f56565;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .treasure {
            background-color: #f6e05e;
            animation: shine 1s infinite;
        }
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .game-over.active { display: flex; }
        .heart-full {
            color: #f56565;
            display: inline-block;
            margin: 0 2px;
        }
        .heart-empty {
            color: #4a5568;
            display: inline-block;
            margin: 0 2px;
        }
        .control-btn:active {
            background: rgba(74, 85, 104, 0.9);
        }
       
        .bullet {
            background-color: white;
            border-radius: 50%;
            width: 10px !important;
            height: 10px !important;
            position: relative;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            animation: shine 1s infinite;
        }

        .shot {
            position: relative;
        }

        .shot::after {
            content: '';
            position: absolute;
            background-color: white;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .enemy-hit {
            animation: explode 0.3s ease-out;
            z-index: 10;
        }

        .heart {
            color: #f56565;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            animation: pulse 2s infinite;
        }

        @keyframes explode {
            0% { 
                transform: scale(1); 
                background-color: #f56565;
            }
            50% { 
                transform: scale(1.8); 
                background-color: #ff9999;
                box-shadow: 0 0 20px #ff0000;
            }
            100% { 
                transform: scale(1); 
                background-color: #f56565;
            }
        }

        @keyframes pulse {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(0.95); }
        }

        @keyframes shine {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">
    <div class="game-container">
      
        <div class="text-white mb-4 text-center">
            <!-- T√≠tulo -->
            <div class="w-full max-w-2xl mx-auto mb-2">
                <h1 class="text-xl md:text-3xl font-bold">Labirinto dos Tesouros</h1>
            </div>
            <!-- Container para as informa√ß√µes do jogo -->
            <div class="flex flex-wrap justify-center gap-4 text-sm md:text-base">
                <div>N√≠vel: <span id="level">1</span></div>
                <div>Pontua√ß√£o: <span id="score">0</span></div>
                <div>Tesouros: <span id="treasures">0</span></div>
                <div>Balas: <span id="bullets">0</span></div>
            </div>
            
            <!-- Container para vidas e bot√£o de pausa -->
            <div class="flex justify-center items-center gap-4 mb-2">
                <div id="lives"></div>
                <button id="pauseButton" class="bg-gray-800 hover:bg-gray-700 text-white font-bold p-0.5 rounded text-xs mt-1">
                    ‚è∏Ô∏è
                </button>
            </div>
        </div>
        
        <!-- Adicione o overlay de pausa logo ap√≥s -->
        <div id="pauseOverlay" class="fixed inset-0 bg-black bg-opacity-80 hidden flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg text-white text-center">
                <h2 class="text-2xl mb-4">Jogo Pausado</h2>
                <p class="hidden md:block mb-4 text-gray-400">Pressione P ou clique para continuar</p>
                <button id="resumeButton" class="bg-green-500 px-4 py-2 rounded hover:bg-green-600">
                    Continuar
                </button>
            </div>
        </div>
        
        <div class="maze-wrapper">
            <div id="maze" class="maze-container"></div>
            <div class="mobile-controls">
                <div class="d-pad">
                    <div class="d-pad-row">
                        <div></div>
                        <div class="control-btn" id="btnUp">üîº</div>
                        <div></div>
                    </div>
                    <div class="d-pad-row">
                        <div class="control-btn" id="btnLeft">‚óÄÔ∏è</div>
                        <div class="control-btn" id="btnDown">üîΩ</div>
                        <div class="control-btn" id="btnRight">‚ñ∂Ô∏è</div>
                    </div>
                </div>
                <div class="shoot-control">
                    <div class="control-btn" id="btnShoot">‚ö™</div>
                </div>
            </div>
         </div>
    </div>
    
    <div id="gameOver" class="game-over">
        <div class="bg-gray-800 p-8 rounded-lg text-white text-center">
            <h2 class="text-2xl mb-4">Game Over!</h2>
            <p class="mb-4">N√≠vel Alcan√ßado: <span id="finalLevel">0</span></p>
            <p class="mb-4">Pontua√ß√£o Final: <span id="finalScore">0</span></p>
            <p class="hidden md:block mb-4 text-gray-400">Pressione Enter para jogar novamente</p>
            <button onclick="startGame()" class="md:hidden bg-green-500 px-4 py-2 rounded hover:bg-green-600">
                Clique aqui para jogar novamente
            </button>
        </div>
    </div>

    <script>
        const MAZE_SIZE = 15;
        let maze = [];
        let player = { x: 1, y: 1 };
        let enemies = [];
        let treasures = [];
        let level = 0;
        let score = 0;
        let lives = 0;
        let gameInterval;
        let isGameOver = false;
        let moveCounter = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let moveInterval = null;
        let moveSpeed = 150; // Velocidade inicial de movimento
        let holdStartTime = 0;
        let currentDirection = null;
        let bullets = 0;
        let shots = [];
        let lastDirection = 'right'; // Dire√ß√£o inicial do jogador
        let bulletSpawnChance = 0.025;
        let isPaused = false;
        let heartSpawnChance = 0.009; // 0,9% de chance de gerar cora√ß√£o

        // _________________________________________________________________
        //
        // Controle do som
        // _________________________________________________________________

        class AudioManager {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.sounds = {};
                this.isMuted = false;
                this.loadSounds();
            }

            async loadSounds() {
                // Fun√ß√£o auxiliar para tocar uma sequ√™ncia de notas
                const playSequence = (notes) => {
                    notes.forEach((note, index) => {
                        setTimeout(() => {
                            const oscillator = this.context.createOscillator();
                            const gainNode = this.context.createGain();
                            
                            oscillator.type = note.type || 'sine';
                            oscillator.frequency.setValueAtTime(note.frequency, this.context.currentTime);
                            
                            gainNode.gain.setValueAtTime(note.gain || 0.2, this.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + note.duration);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.context.destination);
                            
                            oscillator.start();
                            oscillator.stop(this.context.currentTime + note.duration);
                        }, index * 100); // 100ms entre cada nota
                    });
                };

                // Fun√ß√£o auxiliar para criar sons usando oscilador
                const createOscillatorSound = (frequency, duration, type = 'sine') => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = type;
                    oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    return { oscillator, gainNode, duration };
                };

                // Som de tiro (som agudo curto)
                this.sounds.shoot = () => {
                    const sound = createOscillatorSound(880, 0.1, 'square');
                    sound.oscillator.start();
                    sound.oscillator.stop(this.context.currentTime + sound.duration);
                };

                // Som de coleta de tesouro (som ascendente)
                this.sounds.collectTreasure = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, this.context.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0.5, this.context.currentTime); // Aumentado de ~0.2 para 0.5
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.2);
                };

                // Som de morte do inimigo (som descendente com ru√≠do)
                this.sounds.enemyDeath = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(110, this.context.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.3);
                };

                // Som de morte do jogador (som grave e longo)
                this.sounds.playerDeath = () => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.context.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(55, this.context.currentTime + 0.5);
                    
                    gainNode.gain.setValueAtTime(0.7, this.context.currentTime); // Aumentado de 0.4 para 0.7
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.5);
                };

                // Melodia de game over (sequ√™ncia de notas tristes descendentes)
                this.sounds.gameOver = () => {
                    const baseFreq = 440; // Nota A4
                    const notes = [
                        { frequency: baseFreq, duration: 0.2, type: 'sine', gain: 0.5 },      // A4 (mais alto)
                        { frequency: baseFreq * 0.75, duration: 0.2, type: 'sine', gain: 0.45 }, // F4
                        { frequency: baseFreq * 0.5, duration: 0.4, type: 'sine', gain: 0.4 }, // A3
                        { frequency: baseFreq * 0.25, duration: 0.6, type: 'sine', gain: 0.35 }  // A2 (ainda aud√≠vel)
                    ];
                    playSequence(notes);
                };

                // Melodia de level up (sequ√™ncia de notas alegres em arpejo)
                this.sounds.levelUp = () => {
                    const baseFreq = 440; // Nota A4
                    const notes = [
                        { frequency: baseFreq, duration: 0.15, type: 'sine', gain: 0.2 },       // A4
                        { frequency: baseFreq * 1.25, duration: 0.15, type: 'sine', gain: 0.2 }, // C#5
                        { frequency: baseFreq * 1.5, duration: 0.15, type: 'sine', gain: 0.2 },  // E5
                        { frequency: baseFreq * 2, duration: 0.2, type: 'sine', gain: 0.25 },    // A5 (mais longa e um pouco mais alta)
                    ];
                    playSequence(notes);
                };
            }

            play(soundName) {
                if (this.isMuted || !this.sounds[soundName]) return;
                
                // Garante que o contexto est√° executando (necess√°rio devido √†s pol√≠ticas dos navegadores)
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                
                this.sounds[soundName]();
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                return this.isMuted;
            }
        }

        // Cria uma inst√¢ncia global do gerenciador de √°udio
        const audioManager = new AudioManager();

        // Adiciona bot√£o de mute na interface
        const addMuteButton = () => {
            const controls = document.querySelector('.flex.justify-center.items-center.gap-4.mb-2');
            const muteButton = document.createElement('button');
            muteButton.className = 'bg-gray-800 hover:bg-gray-700 text-white font-bold p-0.5 rounded text-xs mt-1';
            muteButton.innerHTML = 'üîä';
            muteButton.onclick = () => {
                const isMuted = audioManager.toggleMute();
                muteButton.innerHTML = isMuted ? 'üîà' : 'üîä';
            };
            controls.appendChild(muteButton);
        };

        // Chama a fun√ß√£o para adicionar o bot√£o quando a p√°gina carregar
        window.addEventListener('load', addMuteButton);

        // _________________________________________________________________
        //
        // Labirinto
        // _________________________________________________________________

        function createMaze() {
            maze = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            
            function recursiveBacktracking(x, y) {
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                maze[y][x] = 0;
                
                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;
                    const middleX = x + dx/2;
                    const middleY = y + dy/2;
                    
                    if (nextX > 0 && nextX < MAZE_SIZE - 1 && 
                        nextY > 0 && nextY < MAZE_SIZE - 1 && 
                        maze[nextY][nextX] === 1) {
                        maze[middleY][middleX] = 0;
                        maze[nextY][nextX] = 0;
                        recursiveBacktracking(nextX, nextY);
                    }
                }
            }
            
            recursiveBacktracking(1, 1);
            
            // Aumenta o n√∫mero de caminhos extras (era MAZE_SIZE * 1.5)
            for (let i = 0; i < MAZE_SIZE * 3; i++) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 1) {
                    const neighbors = [
                        [x+1, y], [x-1, y],
                        [x, y+1], [x, y-1]
                    ].filter(([nx, ny]) => 
                        nx > 0 && nx < MAZE_SIZE - 1 &&
                        ny > 0 && ny < MAZE_SIZE - 1 &&
                        maze[ny][nx] === 0
                    );
                    
                    // Aumenta a probabilidade de criar caminhos (era neighbors.length >= 2)
                    if (neighbors.length >= 1 && Math.random() < 0.8) { // Aumentou probabilidade tamb√©m
                        maze[y][x] = 0;
                    }
                }
            }
            
            // Garante √°reas mais abertas perto do jogador e inimigo
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (1 + dx > 0 && 1 + dx < MAZE_SIZE - 1 && 
                        1 + dy > 0 && 1 + dy < MAZE_SIZE - 1) {
                        maze[1 + dy][1 + dx] = 0;
                    }
                    if (MAZE_SIZE - 2 + dx > 0 && MAZE_SIZE - 2 + dx < MAZE_SIZE - 1 && 
                        MAZE_SIZE - 2 + dy > 0 && MAZE_SIZE - 2 + dy < MAZE_SIZE - 1) {
                        maze[MAZE_SIZE - 2 + dy][MAZE_SIZE - 2 + dx] = 0;
                    }
                }
            }
            
            maze[1][1] = 0;
            maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 0;
            
            return maze;
        }

        function placeTreasures() {

            // Aumenta n√∫mero de tesouros ap√≥s n√≠vel 15
            const baseNumTreasures = 3 + Math.floor(level / 2);
            const bonusTreasures = level > 15 ? Math.floor((level - 15) / 3) : 0;
            const numTreasures = Math.min(baseNumTreasures + bonusTreasures, 15); // M√°ximo de 15 tesouros
            
            treasures = [];
            
            while (treasures.length < numTreasures) {
                const x = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (MAZE_SIZE - 2)) + 1;
                
                if (maze[y][x] === 0 && 
                    !treasures.some(t => t.x === x && t.y === y) &&
                    !(x === player.x && y === player.y) &&
                    !enemies.some(e => e.x === x && e.y === y)) {
                    treasures.push({x, y});
                }
            }
        }

        function updateLives() {
            const livesContainer = document.getElementById('lives');
            const heartsHtml = Array(5).fill(0).map((_, i) => 
                i < lives ? '‚ù§Ô∏è' : '<span style="opacity: 0.3">‚ù§Ô∏è</span>'
            ).join('');
            livesContainer.innerHTML = heartsHtml;
        }


        function renderMaze() {
            const mazeElement = document.getElementById('maze');
            mazeElement.innerHTML = '';
            
            for (let y = 0; y < MAZE_SIZE; y++) {
                const row = document.createElement('div');
                row.className = 'maze-row';
                
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    } else {
                        cell.classList.add('path');
                    }
                    
                    if (x === player.x && y === player.y) {
                        cell.classList.add('player');
                    }

                    if (enemies.some(e => e.x === x && e.y === y)) {
                        cell.classList.add('enemy');
                        const enemy = enemies.find(e => e.x === x && e.y === y);
                        if (enemy.exploding) {
                            cell.classList.add('enemy-hit');
                        }
                    }

                    if (treasures.some(t => t.x === x && t.y === y)) {
                        cell.classList.add('treasure');
                    }

                    // Adicione renderiza√ß√£o de tiros
                    if (shots.some(shot => shot.x === x && shot.y === y)) {
                        cell.classList.add('shot');
                    }
                    
                    // Adicione renderiza√ß√£o de balas colet√°veis
                    if (maze[y][x] === 2) { // 2 representa uma bala colet√°vel
                        const bullet = document.createElement('div');
                        bullet.className = 'bullet';
                        cell.appendChild(bullet);
                    }

                    // Adicione renderiza√ß√£o de cora√ß√µes
                    if (maze[y][x] === 3) { // 3 representa um cora√ß√£o
                        const heart = document.createElement('div');
                        heart.className = 'heart';
                        heart.innerHTML = '‚ù§Ô∏è';
                        cell.appendChild(heart);
                    }
                    
                    row.appendChild(cell);
                }
                mazeElement.appendChild(row);
            }

            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('treasures').textContent = treasures.length;
            updateLives();
        }

        function initializeEnemies(numEnemies) {
            let enemies = [];
            
            // Define regi√µes do mapa para distribuir os inimigos
            const regions = [
                { x: MAZE_SIZE - 2, y: MAZE_SIZE - 2 },     // Canto inferior direito
                { x: MAZE_SIZE - 2, y: 1 },                 // Canto superior direito
                { x: 1, y: MAZE_SIZE - 2 },                 // Canto inferior esquerdo
                { x: Math.floor(MAZE_SIZE/2), y: MAZE_SIZE - 2 },  // Centro inferior
                { x: MAZE_SIZE - 2, y: Math.floor(MAZE_SIZE/2) },  // Centro direito
                { x: 1, y: Math.floor(MAZE_SIZE/2) },             // Centro esquerdo
                { x: Math.floor(MAZE_SIZE/2), y: 1 }              // Centro superior
            ];
            
            // Limita o n√∫mero de inimigos ao n√∫mero de regi√µes dispon√≠veis
            const actualNumEnemies = Math.min(numEnemies, regions.length);
            
            // Embaralha as regi√µes para variar as posi√ß√µes iniciais
            const shuffledRegions = [...regions];
            for (let i = shuffledRegions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledRegions[i], shuffledRegions[j]] = [shuffledRegions[j], shuffledRegions[i]];
            }
            
            // Para cada inimigo, usa uma regi√£o diferente
            for (let i = 0; i < actualNumEnemies; i++) {
                const basePosition = shuffledRegions[i];
                
                // Tenta encontrar uma posi√ß√£o v√°lida pr√≥xima √† regi√£o base
                let enemy = null;
                let attempts = 0;
                let maxRadius = 1; // Come√ßa com raio pequeno
                
                while (!enemy && attempts < 20) {
                    // Aumenta o raio de busca a cada 5 tentativas
                    if (attempts % 5 === 0) {
                        maxRadius = Math.min(maxRadius + 1, 3);
                    }
                    
                    // Adiciona uma varia√ß√£o baseada no raio atual
                    const testX = basePosition.x + (Math.floor(Math.random() * (maxRadius * 2 + 1)) - maxRadius);
                    const testY = basePosition.y + (Math.floor(Math.random() * (maxRadius * 2 + 1)) - maxRadius);
                    
                    // Garante que a posi√ß√£o est√° dentro dos limites do labirinto
                    if (testX <= 0 || testX >= MAZE_SIZE - 1 || testY <= 0 || testY >= MAZE_SIZE - 1) {
                        attempts++;
                        continue;
                    }
                    
                    // Verifica se a posi√ß√£o √© v√°lida
                    if (maze[testY][testX] === 0 && 
                        !enemies.some(e => Math.abs(e.x - testX) < 3 && Math.abs(e.y - testY) < 3) &&
                        (Math.abs(player.x - testX) + Math.abs(player.y - testY)) > 6) { // Dist√¢ncia m√≠nima do jogador
                        enemy = { x: testX, y: testY };
                    }
                    
                    attempts++;
                }
                
                // Se n√£o encontrou posi√ß√£o com varia√ß√£o, usa a posi√ß√£o base com verifica√ß√£o adicional
                if (!enemy) {
                    // Verifica se a posi√ß√£o base √© v√°lida
                    if (maze[basePosition.y][basePosition.x] === 0 &&
                        !enemies.some(e => Math.abs(e.x - basePosition.x) < 2 && Math.abs(e.y - basePosition.y) < 2)) {
                        enemy = { x: basePosition.x, y: basePosition.y };
                    } else {
                        // √öltima tentativa: procura qualquer posi√ß√£o v√°lida longe do jogador
                        for (let y = 1; y < MAZE_SIZE - 1; y++) {
                            for (let x = 1; x < MAZE_SIZE - 1; x++) {
                                if (maze[y][x] === 0 &&
                                    !enemies.some(e => Math.abs(e.x - x) < 2 && Math.abs(e.y - y) < 2) &&
                                    (Math.abs(player.x - x) + Math.abs(player.y - y)) > 6) {
                                    enemy = { x, y };
                                    break;
                                }
                            }
                            if (enemy) break;
                        }
                    }
                }
                
                // Se ainda n√£o encontrou posi√ß√£o, usa a base com offset m√≠nimo
                if (!enemy) {
                    enemy = { 
                        x: Math.max(1, Math.min(MAZE_SIZE - 2, basePosition.x + (i % 2))),
                        y: Math.max(1, Math.min(MAZE_SIZE - 2, basePosition.y + (i % 2)))
                    };
                }
                
                enemies.push(enemy);
            }
            
            return enemies;
        }

        // Nova fun√ß√£o para reposicionar um √∫nico inimigo
        function repositionEnemy(currentEnemy) {
            // Encontra todas as posi√ß√µes v√°lidas e suas dist√¢ncias do jogador
            let bestPosition = null;
            let maxDistance = -1;
            
            for (let testY = 1; testY < MAZE_SIZE - 1; testY++) {
                for (let testX = 1; testX < MAZE_SIZE - 1; testX++) {
                    // Verifica se √© uma posi√ß√£o v√°lida
                    if (maze[testY][testX] !== 0) continue;
                    
                    // Verifica se est√° ocupado por outro inimigo
                    if (enemies.some(e => 
                        e !== currentEnemy && // N√£o √© o pr√≥prio inimigo
                        ((e.x === testX && e.y === testY) || // Exatamente mesma posi√ß√£o
                        (Math.abs(e.x - testX) < 2 && Math.abs(e.y - testY) < 2)) // C√©lulas adjacentes
                    )) continue;
                    
                    // Calcula dist√¢ncia Manhattan do jogador
                    const distance = Math.abs(player.x - testX) + Math.abs(player.y - testY);
                    
                    // Atualiza melhor posi√ß√£o se encontrar uma dist√¢ncia maior
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        bestPosition = { x: testX, y: testY };
                    }
                }
            }
            
            // Se encontrou uma posi√ß√£o v√°lida, usa ela
            if (bestPosition) {
                return bestPosition;
            }
            
            // Fallback para o canto mais distante do jogador com pequena varia√ß√£o
            const offsetX = Math.floor(Math.random() * 3) - 1;
            const offsetY = Math.floor(Math.random() * 3) - 1;
            return {
                x: Math.max(1, Math.min(MAZE_SIZE - 2, ((player.x < MAZE_SIZE/2) ? MAZE_SIZE - 2 : 1) + offsetX)),
                y: Math.max(1, Math.min(MAZE_SIZE - 2, ((player.y < MAZE_SIZE/2) ? MAZE_SIZE - 2 : 1) + offsetY))
            };
        }

        // Fun√ß√£o auxiliar para verificar se uma posi√ß√£o √© caminho v√°lido para inimigos
        function isValidPath(x, y) {
            // Considera como caminho v√°lido:
            // - Caminhos normais (0)
            // - C√©lulas com balas (2)
            // - C√©lulas com cora√ß√µes (3)
            return maze[y][x] === 0 || maze[y][x] === 2 || maze[y][x] === 3;
        }

        // Encontra o menor caminho at√© o player usando BFS
        function findPathToPlayer(enemy) {
            const queue = [{x: enemy.x, y: enemy.y, path: []}];
            const visited = new Set([`${enemy.x},${enemy.y}`]);
            
            // Dire√ß√µes poss√≠veis: cima, direita, baixo, esquerda
            const directions = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Encontrou o player
                if (current.x === player.x && current.y === player.y) {
                    return current.path[0] || current; // Retorna primeiro passo ou posi√ß√£o atual
                }
                
                // Tenta todas as dire√ß√µes
                for (const {dx, dy} of directions) {
                    const nextX = current.x + dx;
                    const nextY = current.y + dy;
                    const key = `${nextX},${nextY}`;
                    
                    // Verifica se movimento √© v√°lido
                    if (nextX >= 0 && nextX < MAZE_SIZE && 
                        nextY >= 0 && nextY < MAZE_SIZE && 
                        isValidPath(nextX, nextY) && 
                        !visited.has(key) &&
                        !enemies.some(e => e !== enemy && e.x === nextX && e.y === nextY)) {
                        
                        visited.add(key);
                        const newPath = [...current.path, {x: nextX, y: nextY}];
                        queue.push({x: nextX, y: nextY, path: newPath});
                    }
                }
            }
            
            return null; // N√£o encontrou caminho
        }

        // Move o inimigo em dire√ß√£o ao player
        function moveEnemy(enemy) {
            if (enemy.exploding) return;
            
            const nextMove = findPathToPlayer(enemy);
            if (!nextMove) return; // Se n√£o h√° caminho, n√£o move
            
            // Move para a pr√≥xima posi√ß√£o do caminho
            enemy.x = nextMove.x;
            enemy.y = nextMove.y;
        }         

        function checkCollision() {
            if (isGameOver) return;

            // Verifica coleta de cora√ß√£o
            if (maze[player.y][player.x] === 3) {
                maze[player.y][player.x] = 0;
                if (lives < 5) {
                    lives++;
                    updateLives();
                    audioManager.play('collectTreasure'); // Usa o mesmo som da coleta de tesouro
                }
                return;
            }

            // Verifica colis√£o com inimigos
            const hitEnemy = enemies.find(enemy => 
                enemy.x === player.x && 
                enemy.y === player.y && 
                !enemy.exploding  // Adiciona esta verifica√ß√£o
            );

            if (hitEnemy) {
                lives--;
                updateLives();

                if (lives > 0) {
                    audioManager.play('playerDeath'); // Adiciona som de morte do jogador
                }

                if (lives <= 0) {
                    gameOver();
                } else {

                    // Reposiciona o jogador
                    player = { x: 1, y: 1 };

                    // Reposiciona todos os inimigos
                    enemies = initializeEnemies(enemies.length); 
                }
                return;
            }
            
            // Verifica coleta de tesouro
            const treasureIndex = treasures.findIndex(t => t.x === player.x && t.y === player.y);
            if (treasureIndex !== -1) {
                treasures.splice(treasureIndex, 1);
                score += 100 * level;
                audioManager.play('collectTreasure'); // Adiciona som de coleta
                
                if (treasures.length === 0) {
                    // Adiciona um pequeno delay antes de chamar levelUp
                    setTimeout(() => {
                        levelUp();
                    }, 300); // 300ms de delay
                }
            }

            // Verifica coleta de balas
            if (maze[player.y][player.x] === 2) {
                maze[player.y][player.x] = 0;
                addBullet();
            }
        }

        function levelUp() {
            level++;
            score += 500 * level;
            maze = createMaze();
            player = { x: 1, y: 1 };
            
            audioManager.play('levelUp');
            
            // Calcula n√∫mero de inimigos baseado no n√≠vel at√© 6
            let numEnemies = Math.min(1 + Math.floor((level - 1) / 3), 6);
            
            // Depois de chegar em 6 inimigos (level >18), mostra aleatorio entre 1 e 4
            if (level > 18) {
                numEnemies = Math.floor(Math.random() * 4) + 1;
            }    
             
            // Usa a nova fun√ß√£o para inicializar inimigos
            enemies = initializeEnemies(numEnemies);
            
            // Calcula probabilidade de spawn de balas
            bulletSpawnChance = Math.min(0.05 + (level * 0.02), 0.3);
            
            // Adiciona balas baseado no n√≠vel
            const minBullets = 2 + Math.floor(level / 3);
            for (let i = 0; i < minBullets; i++) {
                generateNewBullet();
            }
            
            placeTreasures();
        }

        function gameOver() {

            // Toca a melodia de game over
            audioManager.play('gameOver');

            stopContinuousMove();
            isGameOver = true;
            clearInterval(gameInterval);
            document.getElementById('gameOver').classList.add('active');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
        }

        function startGame() {
            stopContinuousMove();
            isGameOver = false;
            level = 1;
            score = 0;
            lives = 5;
            bullets = 30;
            updateBulletsDisplay();
            maze = createMaze();
            player = { x: 1, y: 1 };
            enemies = initializeEnemies(1);
            placeTreasures();
            document.getElementById('gameOver').classList.remove('active');
            updateLives();
            
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            
            setGameInterval();
      }

      function setGameInterval() {

            let moveAccumulator = 0;
            moveCounter = 0;

            // Constantes para velocidade
            const BASE_INTERVAL = 200; // Intervalo base do setInterval em ms
            const BASE_ENEMY_SPEED = 5; // Quantos ticks para mover (5 = mover a cada 1 segundo)
            const SPEED_INCREASE = 0.5; // Quanto diminui do intervalo a cada n√≠vel

            gameInterval = setInterval(() => {
                if (!isPaused) {
                    moveCounter++;
                    
                    // Calcula intervalo de movimento baseado no n√≠vel
                    // Come√ßa em 5 ticks (1 segundo) e diminui 0.5 a cada n√≠vel
                    const moveInterval = Math.max(
                        BASE_ENEMY_SPEED - (Math.floor((level - 1) / 3) * SPEED_INCREASE), 
                        1.2 // Nunca mais r√°pido que 1.2 ticks
                    );
                    
                    // Move quando o contador atinge o intervalo
                    if (moveCounter >= moveInterval) {
                        enemies.forEach(moveEnemy);
                        moveCounter = 0; // Reseta o contador
                    }

                    updateShots();
                    checkCollision();
                    renderMaze();
                    
                    if (Math.random() < bulletSpawnChance) {
                        generateNewBullet();
                    }

                    if (lives <= 2 && Math.random() < heartSpawnChance) {
                        generateHeart();
                    }
                }
            }, BASE_INTERVAL); // 200ms = 5 ticks por segundo
        }

        function updateBulletsDisplay() {
            document.getElementById('bullets').textContent = bullets;
        }

        function generateNewBullet() {
            // Conta quantas balas existem no mapa
            let currentBullets = 0;
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[y][x] === 2) currentBullets++;
                }
            }

            // Se j√° tiver muitas balas, n√£o gera mais
            const maxBullets = 3 + Math.floor(level / 3); // Aumenta com o n√≠vel
            if (currentBullets >= maxBullets) return false;

            // Lista todas as posi√ß√µes v√°lidas
            const validPositions = [];
            for (let y = 1; y < MAZE_SIZE - 1; y++) {
                for (let x = 1; x < MAZE_SIZE - 1; x++) {
                    // Verifica se √© um caminho e est√° longe do jogador e inimigos
                    const farFromPlayer = Math.abs(x - player.x) + Math.abs(y - player.y) > 3;
                    const farFromEnemies = !enemies.some(e => 
                        Math.abs(e.x - x) < 3 && Math.abs(e.y - y) < 3
                    );
                    
                    if (maze[y][x] === 0 && farFromPlayer && farFromEnemies) {
                        validPositions.push({x, y});
                    }
                }
            }

            // Se encontrou posi√ß√µes v√°lidas, escolhe uma aleatoriamente
            if (validPositions.length > 0) {
                const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
                maze[pos.y][pos.x] = 2;
                return true;
            }

            return false;
        }

        function movePlayer(direction) {
            if (isGameOver || isPaused) return;

            lastDirection = direction;
            const newPlayer = { ...player };
            
            if (direction === 'up') newPlayer.y--;
            else if (direction === 'down') newPlayer.y++;
            else if (direction === 'left') newPlayer.x--;
            else if (direction === 'right') newPlayer.x++;
            
            // Modifique esta linha para permitir movimento sobre balas e cora√ß√µes
            if (maze[newPlayer.y][newPlayer.x] === 0 || 
                maze[newPlayer.y][newPlayer.x] === 2 || 
                maze[newPlayer.y][newPlayer.x] === 3) {
                player = newPlayer;
                checkCollision();
                renderMaze();
            }
        }

        // Controles de teclado
        // Adicione esta fun√ß√£o para prevenir as teclas padr√£o
        function preventDefaultForArrowKeys(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }

        // Modifique o event listener do teclado para incluir a preven√ß√£o
        document.addEventListener('keydown', (e) => {
            // Previne scroll com teclas direcionais
            preventDefaultForArrowKeys(e);

            // L√≥gica de game over e Enter
            if (isGameOver && e.key === 'Enter') {
                startGame();
                return;
            }

            // Movimento do jogador
            if (isGameOver) return;

            const key = e.key;
            
            if (key === 'ArrowUp') movePlayer('up');
            else if (key === 'ArrowDown') movePlayer('down');
            else if (key === 'ArrowLeft') movePlayer('left');
            else if (key === 'ArrowRight') movePlayer('right');

            // Controle do tiro
            if (e.key === ' ' || e.code === 'Space') {
                shoot();
                return;
            }
            
            // Tecla P para pausar
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        // Opcionalmente, tamb√©m previna o scroll quando as teclas estiverem pressionadas
        document.addEventListener('keypress', preventDefaultForArrowKeys);

        // Previne comportamentos indesejados do touch
        document.addEventListener('touchstart', (e) => {
            if (e.target.classList.contains('control-btn')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Impede que o usu√°rio d√™ zoom na tela mobile com double tap
        document.addEventListener('dblclick', (e) => {
            e.preventDefault();
        }, { passive: false });

        
        // Fun√ß√£o auxiliar para iniciar movimento cont√≠nuo
        function startContinuousMove(direction) {
            if (moveInterval && currentDirection === direction) return;
            
            stopContinuousMove(); // Limpa qualquer movimento anterior
            currentDirection = direction;
            holdStartTime = Date.now();
            
            movePlayer(direction); // Move imediatamente
            
            moveInterval = setInterval(() => {
                movePlayer(direction);
                
                // Calcula quanto tempo o bot√£o est√° sendo segurado
                const holdDuration = Date.now() - holdStartTime;
                
                // Ajusta a velocidade baseado no tempo segurado
                if (holdDuration > 500) { // Ap√≥s 0.5 segundo
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 30); // Muito r√°pido
                } else if (holdDuration > 200) { // Ap√≥s 0.2 segundos
                    clearInterval(moveInterval);
                    moveInterval = setInterval(() => {
                        movePlayer(direction);
                    }, 100); // R√°pido
                }
            }, moveSpeed);
        }

        function stopContinuousMove() {
            if (moveInterval) {
                clearInterval(moveInterval);
                moveInterval = null;
            }
            moveSpeed = 150; // Reseta a velocidade
            currentDirection = null;
            holdStartTime = 0;
        }

        function addBullet() {
            bullets++;
            updateBulletsDisplay();
        }

        function updateBulletsDisplay() {
            const bulletDisplay = document.getElementById('bullets');
            bulletDisplay.textContent = bullets;
        }

        function findNearestEnemy(fromX, fromY) {
            // Filtra inimigos que n√£o est√£o explodindo e ordena por dist√¢ncia
            const validEnemies = enemies
                .filter(enemy => !enemy.exploding)
                .map(enemy => ({
                    enemy,
                    distance: Math.abs(fromX - enemy.x) + Math.abs(fromY - enemy.y)
                }))
                .sort((a, b) => a.distance - b.distance);
            
            return validEnemies.length > 0 ? validEnemies[0].enemy : null;
        }

        function getDirectionToEnemy(fromX, fromY, enemy) {
            const dx = enemy.x - fromX;
            const dy = enemy.y - fromY;
            
            // Tenta primeiro a dire√ß√£o com maior dist√¢ncia (mais prov√°vel de ter caminho)
            if (Math.abs(dx) > Math.abs(dy)) {
                // Tenta horizontalmente primeiro
                const dirX = dx > 0 ? 'right' : 'left';
                // Verifica se h√° parede imediata na dire√ß√£o horizontal
                if (dx > 0 && maze[fromY][fromX + 1] !== 1 || 
                    dx < 0 && maze[fromY][fromX - 1] !== 1) {
                    return dirX;
                }
                // Se h√° parede, tenta verticalmente
                const dirY = dy > 0 ? 'down' : 'up';
                if (dy > 0 && maze[fromY + 1][fromX] !== 1 || 
                    dy < 0 && maze[fromY - 1][fromX] !== 1) {
                    return dirY;
                }
            } else {
                // Tenta verticalmente primeiro
                const dirY = dy > 0 ? 'down' : 'up';
                // Verifica se h√° parede imediata na dire√ß√£o vertical
                if (dy > 0 && maze[fromY + 1][fromX] !== 1 || 
                    dy < 0 && maze[fromY - 1][fromX] !== 1) {
                    return dirY;
                }
                // Se h√° parede, tenta horizontalmente
                const dirX = dx > 0 ? 'right' : 'left';
                if (dx > 0 && maze[fromY][fromX + 1] !== 1 || 
                    dx < 0 && maze[fromY][fromX - 1] !== 1) {
                    return dirX;
                }
            }
            
            // Se n√£o encontrou dire√ß√£o sem parede, retorna null
            return null;
        }

        function shoot() {
            if (bullets <= 0 || isPaused) return;
            
            const nearestEnemy = findNearestEnemy(player.x, player.y);
            if (!nearestEnemy) return; // N√£o atira se n√£o houver inimigos vivos
            
            const direction = getDirectionToEnemy(player.x, player.y, nearestEnemy);
            if (!direction) return; // N√£o atira se n√£o houver dire√ß√£o v√°lida
            
            bullets--;
            updateBulletsDisplay();
            audioManager.play('shoot');

            const shot = {
                x: player.x,
                y: player.y,
                direction: direction
            };
            
            shots.push(shot);
        }

        function updateShots() {
            for (let i = shots.length - 1; i >= 0; i--) {
                const shot = shots[i];
                let nextX = shot.x;
                let nextY = shot.y;
                
                switch(shot.direction) {
                    case 'up': nextY--; break;
                    case 'down': nextY++; break;
                    case 'left': nextX--; break;
                    case 'right': nextX++; break;
                }
                
                // Remove tiro se bater em parede
                if (maze[nextY][nextX] === 1) {
                    shots.splice(i, 1);
                    continue;
                }
                
                // Verifica colis√£o com inimigos na posi√ß√£o atual E na pr√≥xima posi√ß√£o
                const hitEnemy = enemies.findIndex(enemy => {
                    // Verifica colis√£o na posi√ß√£o atual da bala
                    if (enemy.x === shot.x && enemy.y === shot.y) return true;
                    // Verifica colis√£o na pr√≥xima posi√ß√£o da bala
                    if (enemy.x === nextX && enemy.y === nextY) return true;
                    // Verifica se o inimigo e a bala "cruzaram" caminhos
                    if (enemy.x === nextX && enemy.y === shot.y) return true;
                    if (enemy.x === shot.x && enemy.y === nextY) return true;
                    return false;
                });
                
                if (hitEnemy !== -1 && !enemies[hitEnemy].exploding) {
                    enemies[hitEnemy].exploding = true;
                    shots.splice(i, 1);
                    audioManager.play('enemyDeath'); // Adiciona som de morte do inimigo

                    // Posi√ß√£o atual do inimigo atingido
                    const currentX = enemies[hitEnemy].x;
                    const currentY = enemies[hitEnemy].y;
                    
                    setTimeout(() => {
                        if (enemies[hitEnemy]) {
                            enemies[hitEnemy].exploding = false;
                            const newPos = repositionEnemy(enemies[hitEnemy]);
                            enemies[hitEnemy].x = newPos.x;
                            enemies[hitEnemy].y = newPos.y;
                        }
                    }, 300);
                    continue;
                }
                
                shot.x = nextX;
                shot.y = nextY;
            }
        }

        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            const pauseOverlay = document.getElementById('pauseOverlay');
            
            if (isPaused) {
                // Para tudo limpando o intervalo principal do jogo
                clearInterval(gameInterval);
                pauseOverlay.classList.remove('hidden');
            } else {
                pauseOverlay.classList.add('hidden');
                
                // Recria o intervalo principal do jogo
                setGameInterval();
            }
        }

        function generateHeart() {

            // S√≥ gera cora√ß√£o se o jogador estiver com 1 ou 2 vidas
            if (lives > 2) return false;

            // Lista todas as posi√ß√µes v√°lidas
            const validPositions = [];
            for (let y = 1; y < MAZE_SIZE - 1; y++) {
                for (let x = 1; x < MAZE_SIZE - 1; x++) {
                    // Verifica se √© um caminho e est√° longe do jogador e inimigos
                    const farFromPlayer = Math.abs(x - player.x) + Math.abs(y - player.y) > 3;
                    const farFromEnemies = !enemies.some(e => 
                        Math.abs(e.x - x) < 3 && Math.abs(e.y - y) < 3
                    );
                    
                    if (maze[y][x] === 0 && farFromPlayer && farFromEnemies) {
                        validPositions.push({x, y});
                    }
                }
            }

            // Se encontrou posi√ß√µes v√°lidas, escolhe uma aleatoriamente
            if (validPositions.length > 0) {
                const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
                maze[pos.y][pos.x] = 3; // 3 representa um cora√ß√£o
                return true;
            }

            return false;
        }

        // Atualiza os event listeners dos bot√µes
        ['Up', 'Down', 'Left', 'Right'].forEach(direction => {
            const btn = document.getElementById(`btn${direction}`);
            const dir = direction.toLowerCase();

            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startContinuousMove(dir);
            });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopContinuousMove();
            });

            // Mouse events para desktop
            btn.addEventListener('mousedown', () => {
                startContinuousMove(dir);
            });

            btn.addEventListener('mouseup', () => {
                stopContinuousMove();
            });

            btn.addEventListener('mouseleave', () => {
                stopContinuousMove();
            });
        });

        // Mobile
        document.getElementById('btnShoot').addEventListener('touchstart', (e) => {
            e.preventDefault();
            shoot();
        });

        document.getElementById('btnShoot').addEventListener('click', () => {
            shoot();
        });

        // Pause/Resume
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        document.getElementById('resumeButton').addEventListener('click', togglePause);

        // Inicia o jogo
        startGame();
    </script>
</body>
</html>